package qb_gen

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	"github.com/wyattis/z/zos"
	"github.com/wyattis/z/zset/zstringset"
	"github.com/wyattis/z/zstring"
)

//go:embed template.go.tpl
var genTemplate string

type Config struct {
	structs  []any
	Models   []Model
	Package  string
	RootPath string
	Imports  []string
}

type Field struct {
	Name         string
	ColName      string
	ShouldScan   bool
	ShouldInsert bool
	ShouldUpdate bool
}

type Model struct {
	PackagePath string
	PackageName string
	BuilderName string
	Name        string
	TableName   string

	Fields []Field
}

func (m Model) ScanFields(varName string) string {
	names := []string{}
	for _, field := range m.Fields {
		if field.ShouldScan {
			names = append(names, fmt.Sprintf("%s.%s", varName, field.Name))
		}
	}
	return strings.Join(names, ", ")
}

func (m Model) ModelName() string {
	return fmt.Sprintf("%s.%s", m.PackageName, m.Name)
}

func Generate(config Config, structs ...any) (err error) {
	if config.RootPath == "" {
		config.RootPath = "./"
	}
	config.Package = "qb"
	config.RootPath = filepath.Join(config.RootPath, config.Package)
	config.structs = append(config.structs, structs...)
	if len(config.structs) == 0 && len(config.Models) == 0 {
		return fmt.Errorf("no structs or models specified")
	}

	output := bytes.Buffer{}
	if err = generateInto(config, &output); err != nil {
		return
	}
	fmt.Println("generating into", config.RootPath)
	if err = os.MkdirAll(config.RootPath, 0755); err != nil {
		return
	}
	path := filepath.Join(config.RootPath, fmt.Sprintf("%s.generated.go", config.Package))
	if zos.Exists(path) {
		contents, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		if !bytes.HasPrefix(contents, []byte("// Code generated by qb. DO NOT EDIT.")) {
			return fmt.Errorf("%s exists but is not generated by qb", path)
		}
	}
	fmt.Println("writing to", path)
	return os.WriteFile(path, output.Bytes(), 0644)
}

func generateInto(config Config, w io.Writer) (err error) {
	t, err := template.New("").Parse(genTemplate)
	if err != nil {
		return
	}

	models, err := structsToModels(config.structs)
	if err != nil {
		return
	}
	config.Models = append(config.Models, models...)

	imports := zstringset.New()
	for _, m := range config.Models {
		if m.PackagePath != "" {
			imports.Add(m.PackagePath)
		}
	}
	config.Imports = imports.Items()

	return t.ExecuteTemplate(w, "qb", config)
}

func structsToModels(structs []any) (models []Model, err error) {
	// Extract fields from structs using reflection
	for _, s := range structs {
		t := reflect.TypeOf(s)
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}

		model := Model{
			// the first letter of builder name should be lowercase
			PackagePath: t.PkgPath(),
			PackageName: path.Base(t.PkgPath()),
			BuilderName: strings.ToLower(t.Name()[0:1]) + t.Name()[1:],
			TableName:   zstring.CamelToSnake(t.Name(), "_", 2),
			Name:        t.Name(),
		}
		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			model.Fields = append(model.Fields, Field{
				Name:         field.Name,
				ColName:      zstring.CamelToSnake(field.Name, "_", 2),
				ShouldScan:   true,
				ShouldInsert: strings.ToLower(field.Name) != "id",
				ShouldUpdate: strings.ToLower(field.Name) != "id",
			})
		}
		models = append(models, model)
	}
	return
}
