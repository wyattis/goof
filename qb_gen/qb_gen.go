package qb_gen

import (
	"bytes"
	"database/sql/driver"
	"embed"
	"fmt"
	"io"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/wyattis/z/zos"
	"github.com/wyattis/z/zset"
	"github.com/wyattis/z/zset/zstringset"
	"github.com/wyattis/z/zstring"
)

//go:embed templates/*.go.tpl
var templates embed.FS

type Config struct {
	QueryBuilders      []any
	Crud               []any
	QueryBuilderModels []Model
	CrudModels         []Model
	Package            string
	RootPath           string
	Imports            []Import
	EnableLog          bool
}

type QbConfig struct {
	Models  []Model
	Imports []Import
}

type CrudConfig struct {
	Models  []Model
	Imports []Import
}

type ExecConfig struct {
	Package string
	Log     bool
	Imports []Import
	Qb      QbConfig
	Crud    CrudConfig
}

type Import struct {
	Path  string
	Alias string
}

type Field struct {
	Name           string
	UriName        string
	ColName        string
	IsPrimary      bool
	Type           reflect.Type
	TypeStr        string
	ShouldScan     bool
	ShouldInsert   bool
	ShouldUpdate   bool
	IsPointer      bool
	IsDriverValuer bool
}

type Model struct {
	PackagePath string
	PackageName string
	BuilderName string
	Name        string
	TableName   string

	Fields []Field
}

func (m Model) ScanFields(varName string) string {
	names := []string{}
	for _, field := range m.Fields {
		if field.ShouldScan {
			names = append(names, fmt.Sprintf("&%s.%s", varName, field.Name))
		}
	}
	return strings.Join(names, ", ")
}

func (m Model) ModelName() string {
	return fmt.Sprintf("%s.%s", m.PackageName, m.Name)
}

func (m Model) PrimaryKeys() (res []Field) {
	for _, field := range m.Fields {
		if field.IsPrimary {
			res = append(res, field)
		}
	}
	return
}

func (m Model) PrimaryField() (res Field) {
	primary := m.PrimaryKeys()
	if len(primary) > 1 {
		panic(fmt.Sprintf("model %s has more than one primary key", m.Name))
	}
	return primary[0]
}

func (m Model) UpdateFields() (res []Field) {
	for _, field := range m.Fields {
		if field.ShouldUpdate {
			res = append(res, field)
		}
	}
	return
}

func (m Model) UriName() string {
	return zstring.CamelToSnake(m.Name, "-", 2)
}

func Generate(config Config) (err error) {
	if config.RootPath == "" {
		config.RootPath = "./"
	}
	config.Package = "qb"
	config.RootPath = filepath.Join(config.RootPath, config.Package)

	if len(config.QueryBuilders) == 0 && len(config.Crud) == 0 && len(config.QueryBuilderModels) == 0 && len(config.CrudModels) == 0 {
		return fmt.Errorf("no structs or models specified")
	}

	output := bytes.Buffer{}
	if err = generateInto(config, &output); err != nil {
		return
	}
	fmt.Println("generating into", config.RootPath)
	if err = os.MkdirAll(config.RootPath, 0755); err != nil {
		return
	}
	path := filepath.Join(config.RootPath, fmt.Sprintf("%s.generated.go", config.Package))
	if zos.Exists(path) {
		contents, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		if !bytes.HasPrefix(contents, []byte("// Code generated by qb. DO NOT EDIT.")) {
			return fmt.Errorf("%s exists but is not generated by qb", path)
		}
	}
	fmt.Println("writing to", path)
	return os.WriteFile(path, output.Bytes(), 0644)
}

type IIsZero interface {
	IsZero() bool
}

var funcMap = template.FuncMap{
	"isZero": func(t reflect.Type, prefix, varName string) (res string) {
		name := fmt.Sprintf("%s%s", prefix, varName)
		switch t.Kind() {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			res = fmt.Sprintf("%s == 0", name)
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			res = fmt.Sprintf("%s == 0", name)
		case reflect.Float32, reflect.Float64:
			res = fmt.Sprintf("%s == 0", name)
		case reflect.String:
			res = fmt.Sprintf("%s == \"\"", name)
		case reflect.Bool:
			res = fmt.Sprintf("%s", name)
		case reflect.Ptr:
			res = fmt.Sprintf("%s == nil", name)
		default:
			// if implement IIsZero, use it
			if reflect.PtrTo(t).Implements(reflect.TypeOf((*IIsZero)(nil)).Elem()) {
				res = fmt.Sprintf("%s.IsZero()", name)
			} else {
				panic(fmt.Sprintf("unsupported type %s", t))
			}
		}
		return
	},
}

func generateInto(config Config, w io.Writer) (err error) {
	t, err := template.New("").Funcs(funcMap).ParseFS(templates, "templates/*.go.tpl")
	if err != nil {
		return
	}

	c := ExecConfig{
		Log:     config.EnableLog,
		Package: config.Package,
		Imports: []Import{
			{"context", ""},
			{"database/sql", ""},
			{"errors", ""},
			{"fmt", ""},
			{"strings", ""},
		},
	}

	c.Qb.Models = config.QueryBuilderModels
	c.Crud.Models = config.CrudModels

	qbModels, qbImports := structsToModels(config.QueryBuilders)
	crudModels, crudImports := structsToModels(config.Crud)
	c.Qb.Models = qbModels
	c.Crud.Models = crudModels

	for _, i := range append(qbImports, crudImports...) {
		c.Imports = append(c.Imports, Import{Path: i})
	}

	// Remove duplicates using a hash set
	imports := zset.NewHashSet(func(i Import) string {
		return i.Alias + i.Path
	}, c.Imports...)
	c.Imports = imports.Items()

	hasCrud := len(c.Crud.Models) > 0
	hasQb := len(c.Qb.Models) > 0

	if hasCrud {
		c.Imports = append(c.Imports,
			Import{Path: "github.com/wyattis/goof/gsql"},
			Import{Path: "github.com/wyattis/goof/goof"},
			Import{Path: "github.com/wyattis/goof/route"},
			Import{Path: "github.com/gin-gonic/gin"},
		)
	}

	sort.Slice(c.Imports, func(i, j int) bool {
		return c.Imports[i].Path < c.Imports[j].Path
	})

	if err = t.ExecuteTemplate(w, "package", c); err != nil {
		return
	}

	if hasQb {
		if err = t.ExecuteTemplate(w, "qb", c.Qb); err != nil {
			return
		}
	}

	if hasCrud {
		if err = t.ExecuteTemplate(w, "crud", c.Crud); err != nil {
			return
		}
	}

	return
}

func structsToModels(structs []any) (models []Model, imports []string) {
	importSet := zstringset.New()
	// Extract fields from structs using reflection
	for _, s := range structs {

		t := reflect.TypeOf(s)
		methods := getAllStructMethods(t)
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}

		model := Model{
			// the first letter of builder name should be lowercase
			PackagePath: t.PkgPath(),
			PackageName: path.Base(t.PkgPath()),
			BuilderName: strings.ToLower(t.Name()[0:1]) + t.Name()[1:],
			TableName:   zstring.CamelToSnake(t.Name(), "_", 2),
			Name:        t.Name(),
		}
		if model.PackagePath != "" {
			importSet.Add(model.PackagePath)
		}
		defaultSetters := zset.New[string]()
		for _, method := range methods {
			if strings.HasPrefix(method.Name, "SetDefault") {
				defaultSetters.Add(method.Name[10:])
			}
		}
		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			model.Fields = append(model.Fields, Field{
				Name:           field.Name,
				ColName:        zstring.CamelToSnake(field.Name, "_", 1),
				UriName:        zstring.CamelToSnake(model.Name+field.Name, "_", 1),
				Type:           field.Type,
				TypeStr:        field.Type.String(),
				ShouldScan:     true,
				IsPrimary:      strings.ToLower(field.Name) == "id",
				ShouldInsert:   strings.ToLower(field.Name) != "id",
				ShouldUpdate:   strings.ToLower(field.Name) != "id",
				IsPointer:      field.Type.Kind() == reflect.Ptr,
				IsDriverValuer: field.Type.Implements(reflect.TypeOf((*driver.Valuer)(nil)).Elem()),
			})
			if field.Type.PkgPath() != "" {
				importSet.Add(field.Type.PkgPath())
			}
		}
		models = append(models, model)
	}
	imports = importSet.Items()
	return
}

func getAllStructMethods(t reflect.Type) (methods []reflect.Method) {
	if t.Kind() != reflect.Ptr {
		t = reflect.PtrTo(t)
	}
	for i := 0; i < t.NumMethod(); i++ {
		methods = append(methods, t.Method(i))
	}
	return
}
