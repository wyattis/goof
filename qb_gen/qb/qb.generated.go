// Code generated by qb. DO NOT EDIT.
package qb

import (
  "context"
  "database/sql"
  "fmt"
  "strings"

  "github.com/wyattis/goof/qb_gen/test_models"
  
)


type expression struct {
	expr   string
	params []any
}

type order struct {
  column string
  desc   bool
}

// SQL Database interfaces
type ISelect interface {
	Select(dest any, query string, params ...interface{}) error
	Get(dest any, query string, params ...interface{}) error
}

type ISelectContext interface {
	SelectContext(ctx context.Context, dest any, query string, params ...interface{}) error
	GetContext(ctx context.Context, dest any, query string, params ...interface{}) error
}

type IQuery interface {
	Query(sql string, params ...interface{}) (*sql.Rows, error)
}

type IQueryContext interface {
	QueryContext(ctx context.Context, sql string, params ...interface{}) (*sql.Rows, error)
}

type IQueryRow interface {
	QueryRow(sql string, params ...interface{}) *sql.Row
}

type IQueryRowContext interface {
	QueryRowContext(ctx context.Context, sql string, params ...interface{}) *sql.Row
}

type IExec interface {
	Exec(sql string, params ...interface{}) (sql.Result, error)
}

type IExecContext interface {
	ExecContext(ctx context.Context, sql string, params ...interface{}) (sql.Result, error)
}

type INamedExec interface {
	NamedExec(query string, arg interface{}) (sql.Result, error)
}

type INamedExecContext interface {
	NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error)
}

type IBegin interface {
	Begin() (*sql.Tx, error)
}

type IBeginTx interface {
	BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error)
}

type IDB interface {
	IExec
	IQuery
	IQueryRow
	IBegin
}

type IDBContext interface {
	IExecContext
	IQueryContext
	IQueryRowContext
	IBeginTx
}






type userWhere struct {
  parent *userSelectBuilder
  expressions []expression
}


func (w *userWhere) Id(expr string, params ...any) *userWhere {
  expr = fmt.Sprintf("id " + expr)
  if !strings.Contains(expr, "?") {
    expr += " ?"
  }
  w.expressions = append(w.expressions, expression{expr, params})
  return w
}

func (w *userWhere) Name(expr string, params ...any) *userWhere {
  expr = fmt.Sprintf("name " + expr)
  if !strings.Contains(expr, "?") {
    expr += " ?"
  }
  w.expressions = append(w.expressions, expression{expr, params})
  return w
}


func (w userWhere) OrderBy(column string) *userSelectBuilder {
  return w.parent.OrderBy(column)
}

func (w userWhere) OrderByDesc(column string) *userSelectBuilder {
  return w.parent.OrderByDesc(column)
}

func (w userWhere) Limit(limit int) *userSelectBuilder {
  return w.parent.Limit(limit)
}

func (w userWhere) Offset(offset int) *userSelectBuilder {
  return w.parent.Offset(offset)
}

func (w userWhere) ToSql() (sql string, params []interface{}, err error) {
  return w.parent.ToSql()
}

// Returns a single model matching the query. If the query returns multiple rows, only the first will be returned.
func (w userWhere) Get(db IQueryRow) (model *test_models.User, err error) {
  return w.parent.Get(db)
}

// Same as Get, but with a context.
func (w userWhere) GetContext(ctx context.Context, db IQueryRowContext) (model *test_models.User, err error) {
  return w.parent.GetContext(ctx, db)
}

// Same as Get, but scans the result into the provided model.
func (w userWhere) GetScan(model *test_models.User, db IQueryRow) (err error) {
  return w.parent.GetScan(model, db)
}

// Same as GetScan, but with a context.
func (w userWhere) GetScanContext(ctx context.Context, model *test_models.User, db IQueryRowContext) (err error) {
  return w.parent.GetScanContext(ctx, model, db)
}



// The list of fields that will be selected by default
var userDefaultSelectFields = []string{
  "id","name",
}

// The list of fields that will be inserted by default
var userDefaultInsertFields = []string{
  "name",
}

// The list of fields that will be updated by default
var userDefaultUpdateFields = []string{
  "name",
}

// Our select query builder for the model test_models.User
type userSelectBuilder struct {
  columns []string
  from string
  orderBy []order
  limit int
  offset int

  Where *userWhere
}

func newuserSelectBuilder() *userSelectBuilder {
  b := &userSelectBuilder{ }
  b.Where = &userWhere{ parent: b }
  return b
}

// Define the columns to select with this query
func (b *userSelectBuilder) Columns(columns ...string) *userSelectBuilder {
  b.columns = columns
  return b
}

// Define the table to select from. If not provided, this will be inferred from the TableName() method on the model if 
// it exists, otherwise it will be inferred from the model name.
func (b *userSelectBuilder) From(from string) *userSelectBuilder {
  b.from = from
  return b
}

// Order by the given column in ascending order.
func (b *userSelectBuilder) OrderBy(column string) *userSelectBuilder {
  b.orderBy = append(b.orderBy, order{column, false})
  return b
}

// Order by the given column in descending order.
func (b *userSelectBuilder) OrderByDesc(column string) *userSelectBuilder {
  b.orderBy = append(b.orderBy, order{column, true})
  return b
}

// Limit the number of results returned by the query.
func (b *userSelectBuilder) Limit(limit int) *userSelectBuilder {
  b.limit = limit
  return b
}

// Offset the results returned by the query.
func (b *userSelectBuilder) Offset(offset int) *userSelectBuilder {
  b.offset = offset
  return b
}

// Returns a single model matching the query. If the query returns multiple rows, only the first will be returned.
func (b *userSelectBuilder) Get(db IQueryRow) (model *test_models.User, err error) {
  model = &test_models.User{}
  err = b.GetScan(model, db)
  return 
}

// Same as Get, but with a context.
func (b *userSelectBuilder) GetContext(ctx context.Context, db IQueryRowContext) (model *test_models.User, err error) {
  model = &test_models.User{}
  if err = b.GetScanContext(ctx, model, db); err != nil {
    return nil, err
  }
  return
}

// Same as Get, but scans the result into the provided model.
func (b *userSelectBuilder) GetScan(model *test_models.User, db IQueryRow) (err error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return
  }
  err = db.QueryRow(sql, params...).Scan(model.Id, model.Name)
  return
}

// Same as GetScan, but with a context.
func (b *userSelectBuilder) GetScanContext(ctx context.Context, model *test_models.User, db IQueryRowContext) (err error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return
  }
  err = db.QueryRowContext(ctx, sql, params...).Scan(model.Id, model.Name)
  return
}

// Returns the parameterized SQL and parameters for the query.
func (b userSelectBuilder) ToSql() (sql string, params []interface{}, err error) {
  sql = "SELECT "
  if len(b.columns) == 0 {
    sql += strings.Join(userDefaultSelectFields, ", ")
  } else {
    sql += strings.Join(b.columns, ", ")
  }
  if b.from == "" {
    b.from = "user"
  }
  sql += " FROM " + b.from
  if len(b.Where.expressions) > 0 {
    sql += " WHERE "
    for i, e := range b.Where.expressions {
      if i > 0 {
        sql += " AND "
      }
      sql += e.expr
      params = append(params, e.params...)
    }
  }
  if len(b.orderBy) > 0 {
    sql += " ORDER BY "
    for i, o := range b.orderBy {
      if i > 0 {
        sql += ", "
      }
      sql += o.column
      if o.desc {
        sql += " DESC"
      }
    }
  }
  if b.limit > 0 {
    sql += fmt.Sprintf(" LIMIT %d", b.limit)
  }
  if b.offset > 0 {
    sql += fmt.Sprintf(" OFFSET %d", b.offset)
  }
  return
}



type userSelectBuilderFactory struct {}

func (f userSelectBuilderFactory) Columns(columns ...string) *userSelectBuilder {
  return newuserSelectBuilder().Columns(columns...)
}

// Define the table to select from. If not provided, this will be inferred from the TableName() method on the model if 
// it exists, otherwise it will be inferred from the model name.
func (b *userSelectBuilderFactory) From(from string) *userSelectBuilder {
  return newuserSelectBuilder().From(from)
}

// Apply any where conditions for the query. Example usage: Select.FromUser.Where("id = ?", id)
func (b *userSelectBuilderFactory) Where() *userWhere{
  return newuserSelectBuilder().Where
}

// Order by the given column in ascending order.
func (b *userSelectBuilderFactory) OrderBy(column string) *userSelectBuilder {
  return newuserSelectBuilder().OrderBy(column)
}

// Order by the given column in descending order.
func (b *userSelectBuilderFactory) OrderByDesc(column string) *userSelectBuilder {
  return newuserSelectBuilder().OrderByDesc(column)
}

// Limit the number of results returned by the query.
func (b *userSelectBuilderFactory) Limit(limit int) *userSelectBuilder {
  return newuserSelectBuilder().Limit(limit)
}

// Offset the results returned by the query.
func (b *userSelectBuilderFactory) Offset(offset int) *userSelectBuilder {
  return newuserSelectBuilder().Offset(offset)
}

// Returns the parameterized SQL and parameters for the query.
func (b userSelectBuilderFactory) ToSql() (sql string, params []interface{}, err error) {
  return newuserSelectBuilder().ToSql()
}

// Returns a single model matching the query. If the query returns multiple rows, only the first will be returned.
func (b userSelectBuilderFactory) Get(db IQueryRow) (model *test_models.User, err error) {
  return newuserSelectBuilder().Get(db)
}

// Same as Get, but with a context.
func (b userSelectBuilderFactory) GetContext(ctx context.Context, db IQueryRowContext) (model *test_models.User, err error) {
  return newuserSelectBuilder().GetContext(ctx, db)
}

// Same as Get, but scans the result into the provided model.
func (b userSelectBuilderFactory) GetScan(model *test_models.User, db IQueryRow) (err error) {
  return newuserSelectBuilder().GetScan(model, db)
}

// Same as GetScan, but with a context.
func (b userSelectBuilderFactory) GetScanContext(ctx context.Context, model *test_models.User, db IQueryRowContext) (err error) {
  return newuserSelectBuilder().GetScanContext(ctx, model, db)
}



func newuserInsert() *userInsert {
  return &userInsert{ }
}

type userInsert struct {
  values []test_models.User
}

// Define the values to insert with this query
func (b *userInsert) Values(values ...test_models.User) *userInsert {
  b.values = append(b.values, values...)
  return b
}

// Insert a single model into the database.
func (b userInsert) Exec(db IExec) (sql.Result, error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return nil, err
  }
  return db.Exec(sql, params...)
}

// Same as Exec, but with a context.
func (b userInsert) ExecContext(ctx context.Context, db IExecContext) (sql.Result, error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return nil, err
  }
  return db.ExecContext(ctx, sql, params...)
}

// Returns the parameterized SQL and parameters for the query.
func (b userInsert) ToSql() (sql string, params []interface{}, err error) {
  sql = "INSERT INTO user ("
  var cols []string
  var vals []string
  
  cols = append(cols, "name")
  vals = append(vals, "?")
  
  sql += strings.Join(cols, ", ") + ") VALUES "
  valsStr := "(" + strings.Join(vals, ", ") + ")"
  for i, v := range b.values {
    if i > 0 {
      sql += ", "
    }
    sql += valsStr
    params = append(params,
      v.Name,
    )
  }
  return
}




type userInsertFactory struct {}

func (f userInsertFactory) Values(values ...test_models.User) *userInsert {
  return newuserInsert().Values(values...)
}






type commentWhere struct {
  parent *commentSelectBuilder
  expressions []expression
}


func (w *commentWhere) Id(expr string, params ...any) *commentWhere {
  expr = fmt.Sprintf("id " + expr)
  if !strings.Contains(expr, "?") {
    expr += " ?"
  }
  w.expressions = append(w.expressions, expression{expr, params})
  return w
}

func (w *commentWhere) UserId(expr string, params ...any) *commentWhere {
  expr = fmt.Sprintf("user_id " + expr)
  if !strings.Contains(expr, "?") {
    expr += " ?"
  }
  w.expressions = append(w.expressions, expression{expr, params})
  return w
}

func (w *commentWhere) Body(expr string, params ...any) *commentWhere {
  expr = fmt.Sprintf("body " + expr)
  if !strings.Contains(expr, "?") {
    expr += " ?"
  }
  w.expressions = append(w.expressions, expression{expr, params})
  return w
}


func (w commentWhere) OrderBy(column string) *commentSelectBuilder {
  return w.parent.OrderBy(column)
}

func (w commentWhere) OrderByDesc(column string) *commentSelectBuilder {
  return w.parent.OrderByDesc(column)
}

func (w commentWhere) Limit(limit int) *commentSelectBuilder {
  return w.parent.Limit(limit)
}

func (w commentWhere) Offset(offset int) *commentSelectBuilder {
  return w.parent.Offset(offset)
}

func (w commentWhere) ToSql() (sql string, params []interface{}, err error) {
  return w.parent.ToSql()
}

// Returns a single model matching the query. If the query returns multiple rows, only the first will be returned.
func (w commentWhere) Get(db IQueryRow) (model *test_models.Comment, err error) {
  return w.parent.Get(db)
}

// Same as Get, but with a context.
func (w commentWhere) GetContext(ctx context.Context, db IQueryRowContext) (model *test_models.Comment, err error) {
  return w.parent.GetContext(ctx, db)
}

// Same as Get, but scans the result into the provided model.
func (w commentWhere) GetScan(model *test_models.Comment, db IQueryRow) (err error) {
  return w.parent.GetScan(model, db)
}

// Same as GetScan, but with a context.
func (w commentWhere) GetScanContext(ctx context.Context, model *test_models.Comment, db IQueryRowContext) (err error) {
  return w.parent.GetScanContext(ctx, model, db)
}



// The list of fields that will be selected by default
var commentDefaultSelectFields = []string{
  "id","user_id","body",
}

// The list of fields that will be inserted by default
var commentDefaultInsertFields = []string{
  "user_id","body",
}

// The list of fields that will be updated by default
var commentDefaultUpdateFields = []string{
  "user_id","body",
}

// Our select query builder for the model test_models.Comment
type commentSelectBuilder struct {
  columns []string
  from string
  orderBy []order
  limit int
  offset int

  Where *commentWhere
}

func newcommentSelectBuilder() *commentSelectBuilder {
  b := &commentSelectBuilder{ }
  b.Where = &commentWhere{ parent: b }
  return b
}

// Define the columns to select with this query
func (b *commentSelectBuilder) Columns(columns ...string) *commentSelectBuilder {
  b.columns = columns
  return b
}

// Define the table to select from. If not provided, this will be inferred from the TableName() method on the model if 
// it exists, otherwise it will be inferred from the model name.
func (b *commentSelectBuilder) From(from string) *commentSelectBuilder {
  b.from = from
  return b
}

// Order by the given column in ascending order.
func (b *commentSelectBuilder) OrderBy(column string) *commentSelectBuilder {
  b.orderBy = append(b.orderBy, order{column, false})
  return b
}

// Order by the given column in descending order.
func (b *commentSelectBuilder) OrderByDesc(column string) *commentSelectBuilder {
  b.orderBy = append(b.orderBy, order{column, true})
  return b
}

// Limit the number of results returned by the query.
func (b *commentSelectBuilder) Limit(limit int) *commentSelectBuilder {
  b.limit = limit
  return b
}

// Offset the results returned by the query.
func (b *commentSelectBuilder) Offset(offset int) *commentSelectBuilder {
  b.offset = offset
  return b
}

// Returns a single model matching the query. If the query returns multiple rows, only the first will be returned.
func (b *commentSelectBuilder) Get(db IQueryRow) (model *test_models.Comment, err error) {
  model = &test_models.Comment{}
  err = b.GetScan(model, db)
  return 
}

// Same as Get, but with a context.
func (b *commentSelectBuilder) GetContext(ctx context.Context, db IQueryRowContext) (model *test_models.Comment, err error) {
  model = &test_models.Comment{}
  if err = b.GetScanContext(ctx, model, db); err != nil {
    return nil, err
  }
  return
}

// Same as Get, but scans the result into the provided model.
func (b *commentSelectBuilder) GetScan(model *test_models.Comment, db IQueryRow) (err error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return
  }
  err = db.QueryRow(sql, params...).Scan(model.Id, model.UserId, model.Body)
  return
}

// Same as GetScan, but with a context.
func (b *commentSelectBuilder) GetScanContext(ctx context.Context, model *test_models.Comment, db IQueryRowContext) (err error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return
  }
  err = db.QueryRowContext(ctx, sql, params...).Scan(model.Id, model.UserId, model.Body)
  return
}

// Returns the parameterized SQL and parameters for the query.
func (b commentSelectBuilder) ToSql() (sql string, params []interface{}, err error) {
  sql = "SELECT "
  if len(b.columns) == 0 {
    sql += strings.Join(commentDefaultSelectFields, ", ")
  } else {
    sql += strings.Join(b.columns, ", ")
  }
  if b.from == "" {
    b.from = "comment"
  }
  sql += " FROM " + b.from
  if len(b.Where.expressions) > 0 {
    sql += " WHERE "
    for i, e := range b.Where.expressions {
      if i > 0 {
        sql += " AND "
      }
      sql += e.expr
      params = append(params, e.params...)
    }
  }
  if len(b.orderBy) > 0 {
    sql += " ORDER BY "
    for i, o := range b.orderBy {
      if i > 0 {
        sql += ", "
      }
      sql += o.column
      if o.desc {
        sql += " DESC"
      }
    }
  }
  if b.limit > 0 {
    sql += fmt.Sprintf(" LIMIT %d", b.limit)
  }
  if b.offset > 0 {
    sql += fmt.Sprintf(" OFFSET %d", b.offset)
  }
  return
}



type commentSelectBuilderFactory struct {}

func (f commentSelectBuilderFactory) Columns(columns ...string) *commentSelectBuilder {
  return newcommentSelectBuilder().Columns(columns...)
}

// Define the table to select from. If not provided, this will be inferred from the TableName() method on the model if 
// it exists, otherwise it will be inferred from the model name.
func (b *commentSelectBuilderFactory) From(from string) *commentSelectBuilder {
  return newcommentSelectBuilder().From(from)
}

// Apply any where conditions for the query. Example usage: Select.FromComment.Where("id = ?", id)
func (b *commentSelectBuilderFactory) Where() *commentWhere{
  return newcommentSelectBuilder().Where
}

// Order by the given column in ascending order.
func (b *commentSelectBuilderFactory) OrderBy(column string) *commentSelectBuilder {
  return newcommentSelectBuilder().OrderBy(column)
}

// Order by the given column in descending order.
func (b *commentSelectBuilderFactory) OrderByDesc(column string) *commentSelectBuilder {
  return newcommentSelectBuilder().OrderByDesc(column)
}

// Limit the number of results returned by the query.
func (b *commentSelectBuilderFactory) Limit(limit int) *commentSelectBuilder {
  return newcommentSelectBuilder().Limit(limit)
}

// Offset the results returned by the query.
func (b *commentSelectBuilderFactory) Offset(offset int) *commentSelectBuilder {
  return newcommentSelectBuilder().Offset(offset)
}

// Returns the parameterized SQL and parameters for the query.
func (b commentSelectBuilderFactory) ToSql() (sql string, params []interface{}, err error) {
  return newcommentSelectBuilder().ToSql()
}

// Returns a single model matching the query. If the query returns multiple rows, only the first will be returned.
func (b commentSelectBuilderFactory) Get(db IQueryRow) (model *test_models.Comment, err error) {
  return newcommentSelectBuilder().Get(db)
}

// Same as Get, but with a context.
func (b commentSelectBuilderFactory) GetContext(ctx context.Context, db IQueryRowContext) (model *test_models.Comment, err error) {
  return newcommentSelectBuilder().GetContext(ctx, db)
}

// Same as Get, but scans the result into the provided model.
func (b commentSelectBuilderFactory) GetScan(model *test_models.Comment, db IQueryRow) (err error) {
  return newcommentSelectBuilder().GetScan(model, db)
}

// Same as GetScan, but with a context.
func (b commentSelectBuilderFactory) GetScanContext(ctx context.Context, model *test_models.Comment, db IQueryRowContext) (err error) {
  return newcommentSelectBuilder().GetScanContext(ctx, model, db)
}



func newcommentInsert() *commentInsert {
  return &commentInsert{ }
}

type commentInsert struct {
  values []test_models.Comment
}

// Define the values to insert with this query
func (b *commentInsert) Values(values ...test_models.Comment) *commentInsert {
  b.values = append(b.values, values...)
  return b
}

// Insert a single model into the database.
func (b commentInsert) Exec(db IExec) (sql.Result, error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return nil, err
  }
  return db.Exec(sql, params...)
}

// Same as Exec, but with a context.
func (b commentInsert) ExecContext(ctx context.Context, db IExecContext) (sql.Result, error) {
  sql, params, err := b.ToSql()
  if err != nil {
    return nil, err
  }
  return db.ExecContext(ctx, sql, params...)
}

// Returns the parameterized SQL and parameters for the query.
func (b commentInsert) ToSql() (sql string, params []interface{}, err error) {
  sql = "INSERT INTO comment ("
  var cols []string
  var vals []string
  
  cols = append(cols, "user_id")
  vals = append(vals, "?")
  
  cols = append(cols, "body")
  vals = append(vals, "?")
  
  sql += strings.Join(cols, ", ") + ") VALUES "
  valsStr := "(" + strings.Join(vals, ", ") + ")"
  for i, v := range b.values {
    if i > 0 {
      sql += ", "
    }
    sql += valsStr
    params = append(params,
      v.UserId,v.Body,
    )
  }
  return
}




type commentInsertFactory struct {}

func (f commentInsertFactory) Values(values ...test_models.Comment) *commentInsert {
  return newcommentInsert().Values(values...)
}





// Define our exported Select builders
var Select struct {
  // Build a select query for the model User
  FromUser userSelectBuilderFactory
  // Build a select query for the model Comment
  FromComment commentSelectBuilderFactory
  
} = struct {
  FromUser userSelectBuilderFactory
  FromComment commentSelectBuilderFactory
  
}{}

// Define our export Insert builders
var Insert struct {
  // Build an insert query for the model User
  IntoUser userInsertFactory// Build an insert query for the model Comment
  IntoComment commentInsertFactory
} = struct {
  IntoUser userInsertFactory
  IntoComment commentInsertFactory
  
}{}

