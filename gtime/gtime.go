// Code generated by go generate; DO NOT EDIT.

// Package gtime provides database wrappers for all of the formats provided in the time package that will format and 
// parse the time.Time type to and from the database using that format.

package gtime

import (
  "database/sql/driver"
  "fmt"
  "time"
)

// parseLayout parses a time.Time from a string or []byte using the given layout
func parseLayout(src any, layout string) (t time.Time, err error) {
	switch src := src.(type) {
	case time.Time:
		t = src
	case string:
		t, err = time.Parse(layout, src)
		if err != nil {
			return
		}
	case []byte:
		t, err = time.Parse(layout, string(src))
		if err != nil {
			return
		}
	default:
		err = fmt.Errorf("unsupported type: %T", src)
	}
	return
}

type formattable interface {
	Format(layout string) string
}


const TimeANSICFormat = time.ANSIC // The format used for ANSIC

// TimeANSIC is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeANSICFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeANSIC struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeANSIC) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeANSICFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeANSIC) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeANSIC) String() string {
	return t.Time.Format(TimeANSICFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeANSIC) Equal(other formattable) bool {
	return t.String() == other.Format(TimeANSICFormat)
}


const TimeUnixDateFormat = time.UnixDate // The format used for UnixDate

// TimeUnixDate is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeUnixDateFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeUnixDate struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeUnixDate) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeUnixDateFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeUnixDate) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeUnixDate) String() string {
	return t.Time.Format(TimeUnixDateFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeUnixDate) Equal(other formattable) bool {
	return t.String() == other.Format(TimeUnixDateFormat)
}


const TimeRubyDateFormat = time.RubyDate // The format used for RubyDate

// TimeRubyDate is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRubyDateFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeRubyDate struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRubyDate) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRubyDateFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRubyDate) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRubyDate) String() string {
	return t.Time.Format(TimeRubyDateFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRubyDate) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRubyDateFormat)
}


const TimeRFC822Format = time.RFC822 // The format used for RFC822

// TimeRFC822 is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRFC822Format`. If the value is zero when `Value()` is called, it will use the current time
type TimeRFC822 struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRFC822) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRFC822Format)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRFC822) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRFC822) String() string {
	return t.Time.Format(TimeRFC822Format)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRFC822) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRFC822Format)
}


const TimeRFC822ZFormat = time.RFC822Z // The format used for RFC822Z

// TimeRFC822Z is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRFC822ZFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeRFC822Z struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRFC822Z) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRFC822ZFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRFC822Z) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRFC822Z) String() string {
	return t.Time.Format(TimeRFC822ZFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRFC822Z) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRFC822ZFormat)
}


const TimeRFC850Format = time.RFC850 // The format used for RFC850

// TimeRFC850 is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRFC850Format`. If the value is zero when `Value()` is called, it will use the current time
type TimeRFC850 struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRFC850) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRFC850Format)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRFC850) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRFC850) String() string {
	return t.Time.Format(TimeRFC850Format)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRFC850) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRFC850Format)
}


const TimeRFC1123Format = time.RFC1123 // The format used for RFC1123

// TimeRFC1123 is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRFC1123Format`. If the value is zero when `Value()` is called, it will use the current time
type TimeRFC1123 struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRFC1123) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRFC1123Format)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRFC1123) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRFC1123) String() string {
	return t.Time.Format(TimeRFC1123Format)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRFC1123) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRFC1123Format)
}


const TimeRFC1123ZFormat = time.RFC1123Z // The format used for RFC1123Z

// TimeRFC1123Z is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRFC1123ZFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeRFC1123Z struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRFC1123Z) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRFC1123ZFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRFC1123Z) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRFC1123Z) String() string {
	return t.Time.Format(TimeRFC1123ZFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRFC1123Z) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRFC1123ZFormat)
}


const TimeRFC3339Format = time.RFC3339 // The format used for RFC3339

// TimeRFC3339 is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRFC3339Format`. If the value is zero when `Value()` is called, it will use the current time
type TimeRFC3339 struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRFC3339) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRFC3339Format)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRFC3339) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRFC3339) String() string {
	return t.Time.Format(TimeRFC3339Format)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRFC3339) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRFC3339Format)
}


const TimeRFC3339NanoFormat = time.RFC3339Nano // The format used for RFC3339Nano

// TimeRFC3339Nano is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeRFC3339NanoFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeRFC3339Nano struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeRFC3339Nano) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeRFC3339NanoFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeRFC3339Nano) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeRFC3339Nano) String() string {
	return t.Time.Format(TimeRFC3339NanoFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeRFC3339Nano) Equal(other formattable) bool {
	return t.String() == other.Format(TimeRFC3339NanoFormat)
}


const TimeKitchenFormat = time.Kitchen // The format used for Kitchen

// TimeKitchen is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeKitchenFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeKitchen struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeKitchen) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeKitchenFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeKitchen) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeKitchen) String() string {
	return t.Time.Format(TimeKitchenFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeKitchen) Equal(other formattable) bool {
	return t.String() == other.Format(TimeKitchenFormat)
}


const TimeStampFormat = time.Stamp // The format used for Stamp

// TimeStamp is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeStampFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeStamp struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeStamp) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeStampFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeStamp) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeStamp) String() string {
	return t.Time.Format(TimeStampFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeStamp) Equal(other formattable) bool {
	return t.String() == other.Format(TimeStampFormat)
}


const TimeStampMilliFormat = time.StampMilli // The format used for StampMilli

// TimeStampMilli is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeStampMilliFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeStampMilli struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeStampMilli) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeStampMilliFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeStampMilli) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeStampMilli) String() string {
	return t.Time.Format(TimeStampMilliFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeStampMilli) Equal(other formattable) bool {
	return t.String() == other.Format(TimeStampMilliFormat)
}


const TimeStampMicroFormat = time.StampMicro // The format used for StampMicro

// TimeStampMicro is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeStampMicroFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeStampMicro struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeStampMicro) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeStampMicroFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeStampMicro) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeStampMicro) String() string {
	return t.Time.Format(TimeStampMicroFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeStampMicro) Equal(other formattable) bool {
	return t.String() == other.Format(TimeStampMicroFormat)
}


const TimeStampNanoFormat = time.StampNano // The format used for StampNano

// TimeStampNano is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeStampNanoFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeStampNano struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeStampNano) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeStampNanoFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeStampNano) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeStampNano) String() string {
	return t.Time.Format(TimeStampNanoFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeStampNano) Equal(other formattable) bool {
	return t.String() == other.Format(TimeStampNanoFormat)
}


const TimeDateTimeFormat = "2006-01-02 15:04:05" // The format used for DateTime

// TimeDateTime is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeDateTimeFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeDateTime struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeDateTime) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeDateTimeFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeDateTime) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeDateTime) String() string {
	return t.Time.Format(TimeDateTimeFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeDateTime) Equal(other formattable) bool {
	return t.String() == other.Format(TimeDateTimeFormat)
}


const TimeDateOnlyFormat = "2006-01-02" // The format used for DateOnly

// TimeDateOnly is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeDateOnlyFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeDateOnly struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeDateOnly) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeDateOnlyFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeDateOnly) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeDateOnly) String() string {
	return t.Time.Format(TimeDateOnlyFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeDateOnly) Equal(other formattable) bool {
	return t.String() == other.Format(TimeDateOnlyFormat)
}


const TimeTimeOnlyFormat = "15:04:05" // The format used for TimeOnly

// TimeTimeOnly is a wrapper around time.Time that implements the sql.Scanner and driver.Valuer with the 
// format `TimeTimeOnlyFormat`. If the value is zero when `Value()` is called, it will use the current time
type TimeTimeOnly struct {
  time.Time
}

// Implements the `sql.Scanner` interface
func (t *TimeTimeOnly) Scan(src interface{}) (err error) {
	t.Time, err = parseLayout(src, TimeTimeOnlyFormat)
	return
}

// Implements the `driver.Valuer` interface
func (t TimeTimeOnly) Value() (driver.Value, error) {
	return t.String(), nil
}

func (t TimeTimeOnly) String() string {
	return t.Time.Format(TimeTimeOnlyFormat)
}

// Uses the `Format` method to compare the two values instead of the default
func (t TimeTimeOnly) Equal(other formattable) bool {
	return t.String() == other.Format(TimeTimeOnlyFormat)
}



